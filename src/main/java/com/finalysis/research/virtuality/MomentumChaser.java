package com.finalysis.research.virtuality;

import com.finalysis.research.reality.Exchange;
import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

@Component
public class MomentumChaser {

    private static final Logger logger = LoggerFactory.getLogger(MomentumChaser.class);
    private static final BigDecimal TURNOVER_THRESHOLD = new BigDecimal("200000");
    private static final BigDecimal VOLUME_INCREASE_THRESHOLD = new BigDecimal("1.1");
    private static final BigDecimal PRICE_INCREASE_THRESHOLD = new BigDecimal("1.05");
    private static final BigDecimal STOP_LOSS_PERCENTAGE_THRESHOLD = new BigDecimal("0.02");
    private static String LINE_SEPARATOR = System.getProperty("line.separator");

    @Autowired
    SecurityRepository securityRepository;

    @Autowired
    SecurityPriceRepository securityPriceRepository;

    public void detectBreakout(Exchange exchange, SecurityPricePeriod period, Date openDate) {
        List<Tip> tips = getTips(exchange, period, openDate);
        writeTipsFile(exchange, openDate, tips);
        logger.info("--Done--");
    }

    private void writeTipsFile(Exchange exchange, Date openDate, List<Tip> tips) {
        String dateStr = new SimpleDateFormat("yyyy-MMM-dd").format(openDate);
        StringBuilder sb = new StringBuilder("Tips in alphabetic order at ").append(exchange.getName()).append(" market close on ").append(dateStr).append(LINE_SEPARATOR)
                .append("* These tips are generated by Momentum Chaser Model for short term trading").append(LINE_SEPARATOR)
                .append("* They are meant to generate 2-10% profit in 2-3 days time frame").append(LINE_SEPARATOR)
                .append("* Strict stop loss execution is key to success of this model").append(LINE_SEPARATOR).append(LINE_SEPARATOR);
        final int NUMBER_FIXED_LENGTH = 5, CODE_FIXED_LENGTH = 7, PRICE_RANGE_FIXED_LENGTH = 18, STOP_LOSS_FIXED_LENGTH = 12;
        append(sb, "No.", NUMBER_FIXED_LENGTH);
        append(sb, "Code", CODE_FIXED_LENGTH);
        append(sb, "Buy Price Range", PRICE_RANGE_FIXED_LENGTH);
        append(sb, "Stop Loss", STOP_LOSS_FIXED_LENGTH);
        sb.append("Sector");
        sb.append(LINE_SEPARATOR);
        Collections.sort(tips);
        Integer count = 0;
        for (Tip tip : tips) {
            count++;
            logger.info(count + ". Buy " + tip.getSecurity().getCode() + " at " + tip.getBuyPrice() + ", stop loss below " + tip.getStopLoss() + " " + tip.getRiskLevel());
            append(sb, count + ".", NUMBER_FIXED_LENGTH);
            append(sb, tip.getSecurity().getCode(), CODE_FIXED_LENGTH);
            append(sb, tip.getBuyPrice() + " or lower ", PRICE_RANGE_FIXED_LENGTH);
            append(sb, tip.getStopLoss(), STOP_LOSS_FIXED_LENGTH);
            if (tip.getSecurity().getCompany() != null && tip.getSecurity().getCompany().getGicsIndustryGroup() != null) {
                sb.append(tip.getSecurity().getCompany().getGicsIndustryGroup().getName());
            }
            sb.append(LINE_SEPARATOR);
        }
        try {
            String fileName = "buy_tips_" + dateStr + ".txt";
            File file = new File(exchange.getBuyTipsArchive(), fileName);
            FileUtils.write(file, sb);
            FileUtils.copyFile(file, new File("/Users/yangf/Google Drive/daily buy tips", fileName));
        } catch (IOException e) {
            logger.error(e.getMessage(), e);
        }
    }

    public List<Tip> getTips(Exchange exchange, SecurityPricePeriod period, Date openDate) {
        List<Security> securities = securityRepository.findActiveByExchange(exchange, openDate);
        return getTips(securities, period, openDate);
    }

    public List<Tip> getTips(List<Security> securities, SecurityPricePeriod period, Date openDate) {
        List<Tip> tips = new ArrayList<>();
        for (Security security : securities) {
            SecurityPrice securityPrice = securityPriceRepository.findByOpenDateAndSecurityAndPeriod(openDate, security, period);
            if (securityPrice != null && securityPrice.getEstimatedTurnover().compareTo(TURNOVER_THRESHOLD) >= 0) {
                List<SecurityPrice> swingPointHighs = securityPriceRepository.findSwingPointHighsBefore(openDate, security, period);
                SecurityPrice swingPointHigh = findClosestSwingPointHighBelow(securityPrice, swingPointHighs);
                if (swingPointHigh != null && isValidBreakout(securityPrice, swingPointHigh)) {
                    tips.add(new Tip(TipType.BREAK_OUT, openDate, security, securityPrice.getCode(), securityPrice.getClosePrice(), swingPointHigh.getMiddlePrice()));
                }
            }
        }
        return tips;
    }

    private void append(StringBuilder sb, Object o, int fixedLength) {
        sb.append(o);
        for (int i = String.valueOf(o).length(); i < fixedLength; i++) {
            sb.append(" ");
        }
    }

    private SecurityPrice findClosestSwingPointHighBelow(SecurityPrice securityPrice, List<SecurityPrice> swingPointHighs) {
        SecurityPrice closestSwingPointHighBelow = null;
        for (SecurityPrice swingPointHigh : swingPointHighs) {
            if (swingPointHigh.getHighestPrice().compareTo(securityPrice.getClosePrice()) < 0
                    && (closestSwingPointHighBelow == null || closestSwingPointHighBelow.getHighestPrice().compareTo(swingPointHigh.getHighestPrice()) < 0)) {
                closestSwingPointHighBelow = swingPointHigh;
            } else {
                break;
            }
        }
        return closestSwingPointHighBelow;
    }

    private boolean isValidBreakout(SecurityPrice securityPrice, SecurityPrice swingPointHigh) {
        BigDecimal volumeIncrease = new BigDecimal(securityPrice.getVolume()).divide(new BigDecimal(swingPointHigh.getVolume()), 2, BigDecimal.ROUND_UP);
        BigDecimal priceIncrease = securityPrice.getClosePrice().divide(swingPointHigh.getHighestPrice(), 3, BigDecimal.ROUND_UP);
        BigDecimal stopLossPercentage = swingPointHigh.getHighestPrice().add(swingPointHigh.getMiddlePrice().negate()).divide(swingPointHigh.getHighestPrice(), 3, BigDecimal.ROUND_UP);
        //TODO should exclude those with potential swing point high and extreme high volume occurred
        return securityPrice.getClosePrice().compareTo(swingPointHigh.getHighestPrice()) > 0
                && securityPrice.getClosePrice().compareTo(securityPrice.getOpenPrice()) > 0
                && priceIncrease.compareTo(PRICE_INCREASE_THRESHOLD) <= 0
                && volumeIncrease.compareTo(VOLUME_INCREASE_THRESHOLD) >= 0
                && stopLossPercentage.compareTo(STOP_LOSS_PERCENTAGE_THRESHOLD) <= 0;
    }
}
